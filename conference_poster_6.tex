%\title{LaTeX Portrait Poster Template}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% a0poster Portrait Poster
% LaTeX Template
% Version 1.0 (22/06/13)
%
% The a0poster class was created by:
% Gerlinde Kettl and Matthias Weiser (tex@kettl.de)
% 
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[a0,portrait]{a0poster}

\usepackage{multicol} % This is so we can have multiple columns of text side-by-side
\columnsep=100pt % This is the amount of white space between the columns in the poster
\columnseprule=3pt % This is the thickness of the black line between the columns in the poster

\usepackage[svgnames]{xcolor} % Specify colors by their 'svgnames', for a full list of all colors available see here: http://www.latextemplates.com/svgnames-colors

\usepackage{times} % Use the times font
%\usepackage{palatino} % Uncomment to use the Palatino font

\usepackage{graphicx} % Required for including images
\graphicspath{{figures/}} % Location of the graphics files
\usepackage{booktabs} % Top and bottom rules for table
\usepackage[font=small,labelfont=bf]{caption} % Required for specifying captions to tables and figures
\usepackage{amsfonts, amsmath, amsthm, amssymb} % For math fonts, symbols and environments
\usepackage{wrapfig} % Allows wrapping text around tables and figures
\usepackage{hyperref}
\usepackage{listings}

\begin{document}

%----------------------------------------------------------------------------------------
%	POSTER HEADER 
%----------------------------------------------------------------------------------------

% The header is divided into two boxes:
% The first is 75% wide and houses the title, subtitle, names, university/organization and contact information
% The second is 25% wide and houses a logo for your university/organization or a photo of you
% The widths of these boxes can be easily edited to accommodate your content as you see fit

\begin{minipage}[b]{0.75\linewidth}
\veryHuge \color{NavyBlue} \textbf{Code Clone Detection in Clang Static Analyzer} \color{Black}\\ % Title
\Huge\textit{Detecting Copy-paste using Static Analysis}\\[2cm] % Subtitle
\huge \textbf{Kirill Bobyrev \& Vassil Vassilev}\\[0.5cm] % Author(s)
\huge MIPT University \& CERN\\[0.4cm] % University/organization
\Large \texttt{kbobyrev@hotmail.com} --- +7-915-118-74-89\\
\Large \texttt{vvasilev@cern.ch}\\
\end{minipage}
%
\begin{minipage}[b]{0.25\linewidth}
\includegraphics[width=20cm]{logo.png}\\
\end{minipage}

\vspace{1cm} % A bit of extra whitespace between the header and poster content

%----------------------------------------------------------------------------------------

\begin{multicols}{2} % This is how many columns your poster will be broken into, a portrait poster is generally split into 2 columns

%----------------------------------------------------------------------------------------
%	INTRODUCTION
%----------------------------------------------------------------------------------------

\color{SaddleBrown} % SaddleBrown color for the introduction

\section*{Introduction}

The copy-paste is a common programming practice. Most of the programmers start from a code snippet, which already exists in the system and modify it to match their needs. Easily, some of the code snippets end up being copied dozens of times. This manual process is error prone, which leads to a seamless introduction of new hard-to-find bugs. Also, copy-paste usually means worse maintainability, understandability and logical design. Clang and Clang's static analyzer provide all the building blocks to build a generic C/C++ copy-paste detecting infrastructure. The infrastructure should be evolved alongside with useful features such as bug checkers and compiler diagnostics.

%----------------------------------------------------------------------------------------
%	OBJECTIVES
%----------------------------------------------------------------------------------------

\color{Black} % Black color for the rest of the content

\section*{Main Objectives}

\begin{enumerate}
\item Research the existing techniques used to detect code clones and analyze their strengths and
weaknesses
\item Implement a simple and fast checker for Clang Static Analyzer, which would have high precision, medium recall and have almost no false-positives in order to be reliant
\item Implement a more sophisticated checker for Clang Static Analyzer, which would have high recall
and possibly generate quite many false-positive reports, but will detect almost any possible clones 
in any codebase
\end{enumerate}

%----------------------------------------------------------------------------------------
%	CODE CLONE TAXONOMY
%----------------------------------------------------------------------------------------

\section*{Code Clone Taxonomy}

Code fragments can be similar in two ways: syntactically and functionally. Code clones of 
types 1, 2 and 3 share different levels of syntactical similarity while code clones of type 4
share functional similarity, i.e. perform identical operations while having completely different
syntax.

\begin{itemize}
\item \textbf{Type 1} Identical code fragments except for variations in whitespace (may be also
variations in layout) and comments. 
\href{https://gist.github.com/omtcyf0/33a00a4f4406f5933526}{Examples}

\item \textbf{Type 2} Structurally/syntactically identical fragments except for variations in identifiers,
literals, types, layout and comments.
\href{https://gist.github.com/omtcyf0/1e6812f98302f374da53}{Examples}

\item \textbf{Type 3} Copied fragments with further modifications. Statements can be changed,
added or removed in addition to variations in identifiers, literals, types, layout
and comments
\href{https://gist.github.com/omtcyf0/dde978ef6696cf47aff8}{Examples}

\item \textbf{Type 4} Two or more code fragments that perform the same computation but
implemented through different syntactic variants.
\href{https://gist.github.com/omtcyf0/2ce1c8962d9a5552cf35}{Examples}
\end{itemize}

%----------------------------------------------------------------------------------------
%	MATERIALS AND METHODS
%----------------------------------------------------------------------------------------

\section*{Materials and Methods}

There are many techniques of code clone detection, which can be divided by the actual material
they process:

\begin{itemize}
\item Text-based Techniques
\item Token-based Techniques
\item Tree-based Techniques
\item PDG-based Techniques
\item Metrics-based Techniques
\end{itemize}

AST-, PDG- and Metrics-based techniques usually have the highest recall and are more precise. 
However, the most successful solutions usually combine few of these techniques in order to use
their strengths.

Both checkers only detect clones in the same TranslationUnit due to Clang Static Analyzer's
singularity.

%------------------------------------------------

\section*{clone.BasicCloneChecker}

The basic clone checker uses the Clang AST infrastructure to find clones in the projects. It's
very fast and has high precision. However, it's recall isn't great and it may miss many clones.

BasicCloneChecker is able to find code clones of types 1 and 2 with high precision. However, it
is very sensitive to the slight changes in analyzed AST. Because of that even slightly changed 
pieces of code (namely Code Clones of type 3) end up not detected. It detects similar sub-trees, so
the detected piece of code should be a sub-tree of a single AST node.

\subsection*{Computational complexity}

It takes $O(s)$ (where s denotes statements count in analyzed AST) time to store all statements 
from the AST and then it takes $O(x)$ (where x denotes each AST node child count) time to build the 
profiles. Hash map is there to provide $O(1)$ computational complexity to access collisions as
two statements and their sub-trees are considered to be clones if hashes of their Profiles are 
equal. It makes the overall (worst-case scenario) computational complexity $O(n^2)$ (where n 
denotes total number of AST nodes).

The heaviest part is building Profiles for each clang::Stmt and if I could make this process 
incremental, so that building Profiles for some tree would have $O(n)$ (where n denotes number of 
nodes in that tree) time instead of $O(n^2)$, I could reduce overall complexity to $O(n)$.

%------------------------------------------------

\section*{clone.AdvancedCloneChecker}

AdvancedCloneChecker combines the Tree- and PDG-based techniques and implements the approach
proposed by Jens Krinke in his paper \cite{FineGrainedPDG}. It detects clones of type 1, 2 and 3. 
It relies on the implemented Fine-Grained PDG data structure, which is basically PDG built from AST 
nodes. Then it runs the maximum similar subgraph searching algorithm to detect similar FGPDG 
subgraphs and creates diagnostics.

The general problem "Finding maximum similar subgraphs" is NP-complete, that is why the implemented 
algorithm is just an approximate approach, which is the best thing one could possibly do.

Granularity is very important part of this approach, because it only processes the comparison
units and the partitioning part is essential. If chosen badly, it can lead to the state, in which
the checker is right now: even if the algorithm extracts subgraphs with fairly good accuracy
not many clones can be detected, because the comparison units are either to big or do not fit
the needed conditions. The implemented algorithm partitions into connected components, which are
compared against each other afterwards. This approach has many negative effects I encountered
while processing large codebases.

\subsection*{Computational complexity}

The overall Computational complexity of the algorithm is $O(n^4)$ and it can not be reduced. It's 
pretty slow, but the approach allows to detect even type 3 clones, which is valuable part.

%----------------------------------------------------------------------------------------
%	RESULTS 
%----------------------------------------------------------------------------------------

\section*{Results}

This shows the performance measurement while compiling few open-source projects with and without
BasicCloneChecker. The same tests weren't performed for AdvancedCloneChecker as it's still not
quite ready to process large codebases.

\begin{lstlisting}[frame=single]
scan-build --use-analyzer=${PATH_TO_BUILT_CLANG} \
-enable-checker clone.BasicCloneChecker          \
-disable-checker core                            \
-disable-checker unix                            \
-disable-checker cplusplus                       \
-disable-checker deadcode                        \
-k make
\end{lstlisting}

\begin{center}\vspace{1cm}
\begin{tabular}{l l l l}
\toprule
\textbf{Project} & \textbf{without fakec invocation, s.} & \textbf{clone.BasicCloneChecker, s.}\\
\midrule
Git &  84 & 144 \\
SDL &  0  & 0   \\
LLVM & 0  & 0   \\
\bottomrule
\end{tabular}
\captionof{table}{\color{Green} Running time measurement}
\end{center}\vspace{1cm}

BasicCloneChecker detects many clones in SDL projects, which show that the library isn't designed
really well. It also detects some clones in Git project. There weren't any reports generated while
compiling LLVM+Clang.

Unfortunately, I am unable to give the exact numbers as the reports contain some false-positives
and garbage warnings at the moment.

AdvancedCloneChecker also generates warnings for Git and SDL projects. No diagnostics were emitted
in the process of compiling LLVM+Clang, too.

LINK TO A SAMPLE REPORT CONTAINING FEW REAL CLONES FROM SDL, GIT, OTHER PROJECTS

%----------------------------------------------------------------------------------------
%	FORTHCOMING IMPROVEMENTS AND CONCLUSION
%----------------------------------------------------------------------------------------

\section*{Forthcoming Improvements and Conclusion}

\begin{itemize}
\item Before presenting clone.BasicCloneChecker to the Clang community and sending its patch to 
the mainline it should no longer produce garbage warnings and and it should emit reports hooked to 
the scan-build engine. It would take few fixes and improvements.
\item However, clone.AdvancedCloneChecker still requires a lot of work: as running on the big 
projects shows the granularity wasn't chosen well enough and it doesn't detect many clones in
various big projects as it was expected. Some of checker parts may be reworked and I'll continue
experimenting with different approaches. Potential new approach that would be tested in future
is applying Value Graph Translation Validation technique \cite{ValueGraphLLVM}
\end{itemize}

%----------------------------------------------------------------------------------------
%	REFERENCES
%----------------------------------------------------------------------------------------

\nocite{*} % Print all references regardless of whether they were cited in the poster or not
\bibliographystyle{plain} % Plain referencing style
\bibliography{biblio} % Use the example bibliography file sample.bib

%----------------------------------------------------------------------------------------
%	ACKNOWLEDGEMENTS
%----------------------------------------------------------------------------------------

\section*{Acknowledgements}

Big thanks to ISP RAS research, who were so kind to share the results of their work with me.

I'd also like to thank Nick Lewycky, who did some initial work on detecting useless conditions
for Clang.

%----------------------------------------------------------------------------------------
%	CODE
%----------------------------------------------------------------------------------------

\section*{Code}

Code is avalible in my \href{https://github.com/omtcyf0/clang}{fork} of Clang on GitHub.

%----------------------------------------------------------------------------------------

\end{multicols}
\end{document}